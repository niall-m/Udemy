- Monolith vs Microservice
    - A monolith contains all the routing, middlewares, business logic, and database access required to implement *all features* of an app
    - A single microservice contains all of that for *one feature* of an app. Everything is self contained.
- The big problem of microservices is *data management between services*, due to how data is stored and accessed
    - Each service gets its own db (*Database-per-Service*), and services *never* reach into the db of another service
        - each service should be independent of other services
        - db schema/structure might change
        - some services might function more efficiently with different types of DB's (sql vs nosql)
- communication strategies between services (not the same meaning as JS!)
    - **sync**: services communicate with each other using *direct requests*
        - conceptually easy to implement
        - could circumnavigate the need for a db 
            - if service C depends on data from services A & B, then C doesn't need a db
        - introduces dependency between services
        - if any inter-service request fails, the overall request fails
        - the entire request is only as fast as the slowest request
        - can introduce complicated webs of requests
            - maybe services A & B also make requests to other services
    - **async** (2 ways): services communicate eith each other using *events* in the *event bus*:
        - event broker: receives events, sends them to interested parties
        - each service emits events to the bus *when they need data*, other services process and return; like a reducer for all services
            - shares all the downsides of sync, not very popular in the wild 
        - services emit an event to event bus *whenever they make entries into their own db*, other services listening for that event type then add the entry to their respective db
            - zero depedencies amongst services
            - very fast, no need to navigate a web of requests
            - data duplication; paying for extra storage (haha), extra db
            - more complicated
- Cors requests (cross origin request sharing)
    - common error with microservices 
    - mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served
    - browser will prevent request unless receiving server provides a specific set of headers 
        - wire up the cors npm package in server as a middleware with `app.use(cors());`
- API request minimization strategies
    - react example: get all posts and their associated comments
    - sync
        - GET request to posts service, post service requests all comments from comments service, post service assembles and returns 
    - async
        - posts/comments services emit an event to event bus any time a post/comment is created
        - query service assembles all posts/comments into an efficient data structure
            - GET request goes to query service instead of posts
- Event Bus
    - several implementations: RabbitMQ, Kafka, NATS
    - receives events, publishes them to listeners
    - many different subtle features that make async communication easier or harder
    - in Express, event is contained in the `req.body` property
- Moderation (whether to approve or reject an action)
    - extract moderation logic into its own service, not in react app (would require frequent redeploys)
    - react app only needs to tell diff between pending, rejected and approved moderation
    - Option #1: middleman approach: introduce moderation service, communicates event creation to query service 
        - comments service emits event saying comment was created
            - moderation service picks up event, processes comment, emits new event saying it was moderated
                - query service persists comment
        - can creates delays between user submitting comment and it being persisted by query service, especially if moderation is approved by hoomans
            - the longer the wait, the worse the UX
        - introduces irrelevent logic and overcomplication to query service as app grows in complexity
    - Option #2: Moderation updates status at both comments and query services
        - comments service emits event saying comment was created
            - both moderation and query service pick up event
                - query service persists immediately with default status of 'pending'
                    - moderation service eventually processes it, emits new event saying it was moderated
                        - query service updates status
        - solves problem of delay (can display placeholder comment for UX)
        - introduces irrelevent logic and overcomplication to query service as app grows in complexity
            - query service is for presentation logic (storing posts and their comments together to avoid multiple API requests)
            - maybe comment can be up/downvoted, promoted, searchable, advertised, etc., query service doesn't/shouldn't care!
                - that business logic should live in the comment service
    - Option #3: query service only listens for 'update' events
        - user submits comment, comment service persists event *with status prop* (of pending) and emits event
            - moderation and query services pick up the creation event
                - moderation processes specialized update and emits event *back to comment service*
                - query service persists comment immediately (with pending status) for UX placeholder
                    - comment service updates status and emits update event
                        - query service picks up update event, updates comment
        - splits events into specialized/specific event (CommentModerated) and general event (CommentUpdated)
        - most modular approach: keeps comment business logic in the comment service