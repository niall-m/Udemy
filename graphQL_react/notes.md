# REST-ful Routing

Given a collection of records on a server, there should be a uniform URL and HTTP request method used to utilize that collection of records. [Set of conventions](https://restfulapi.net/) for CRUD operations, for setting up logical routes that represent the queries made and arguments expected at that route, e.g. `/users/23/friends`. These conventions tend to break down with deeply nested URL routes, which require highly customized queries against highly relational data.

Some shortfall areas with restful routing:
- heavily nested relationships
- making too many requests with heavily nested stuff
- over-fetching data

GraphQL seeks to address these issues with its own queries. GraphQL can serve as a proxy of sorts, to fetch data from multiple sources and ship a response back to user.

- using express, express-graphql, graphql
    - GraphQL-express is the reference implementation of GraphQL
        - official, maintained by facebook, probably safer in terms of big api changes
- Setup express server to handle any incoming requests to route `/graphQL`
    - `app.use('/graphql', graphqlHTTP({ graphiql: true }))`
        - **graphiql** is a dev tool allowing us to make queries against dev server
        - Error: GraphQL middleware options must contain a schema
            - `app.use` is how we wire up middleware to an express app
            - *schema file* describes to graphql how data is arranged and accessed
                - what properties each object has and how each object is related

# Schema File

- buncha functions that return references to other objects in our graph
- each edge of the graph is basically a `resolve()` function (noted below)
- operates off primary/foreign key associations, has many, etc
- create type object variables with `new GraphQLObjectType`, 2 required parameters:
    - name: always a string defining the 'type' we're creating
    - fields: object, key = names of the properties, value = object with *type* property
        - wrapped in specific graphQL types: e.g. `graphql.GraphQLString`, `new GraphQLList(CustomType)`
        - associate other CustomTypes here, for directional restful relations
            - e.g. `/users/21/companies` or `/companies/2/users`
    - try to define types in order
        - if you run into circular references js shenanigans
            - wrap *fields* object in a fat arrow callback to create a closure scope
            - makes a compile-time reference to object returned in *fields* parameter, gets invoked during execution phase, after both Types are defined
        - treat associations between types as though they were another parameter in *fields* 
    - requires a `resolve()` when incoming data model does not have matching parameter names in custom type object being returned
- Root Query: another GraphQLObjectType that acts as the data entry point
    - has name and fields
    - `resolve()` executes the query, requires 2 arguments
        - parentValue: rarely used
        - args: called with whatever arguments were called with original query
        - return JSON object that represents the data 'type' being returned
        - the place for API calls, as graphQL automatically detects promises and waits for them to resolve
    - new GraphQLSchema: takes in a root query(s) and returns a GraphQLSchema instance
- graphiql: browser dev tool for testing queries
    - queries are like javascript, makes use of the root query
    - useful for saving queries into a named variable on frontend
    - use different aliases on fields to fetch both, name result of query by assigning a key (cannot have duplicate keys on an object)
        - `apple: company(id: "1") { ...companyDetails }, google: company(id: "2") { ...companyDetails }`
    - query fragments to make a DRY list of properties
        - `fragment companyDetails on Company { list, of, properties } => ...companyDetails`
- Mutations object
    - like Root Query, exported in the GraphQLSchema
    - can send http requests, for crud ops on the db
    - logic lives separate from Type that it aims to modify
    - only difference is what we do in the `resolve()`
    - the keys of the fields object describe the operation
        - fields: { **addUser**: { type: ${type of data we will eventually return from resolve()} } }
            - collection of data we're operating on and the type we return might not be the same
        - args validation => wrap type with new GraphQlNonNull
            - asserts that a value is being passed in, but nothing more
    - slightly different syntax on graphiql, explicit
        - `mutation { addUser(etc) { etc } }`
    - when calling mutation with arguments, must ask for properties coming back from it (to match the *type* being returned from `resolve()`)
        - always have to assert that there is a Type being returned, even if the properties are null, like an ID after a delete request
        - `addUser(firstName: "Me", age: 30) { id, firstName, age }`
- Clients   
    - integrated to read data from GraphQL server
        - query being sent from browser to server is unformatted (raw query string)
            - graphiql request => network tab => XHR filter => Headers => Request Payload
            - this makes GraphQL client agnostic: each request is processed the same no matter the client
    - React app is coupled with client, which essentially replaces graphiql in production env
        - hand write some queries, feed them into the client
        - client issues request to backend, then passes response back to React app
    - Lokka
        - simple implementation; basic queries/mutations; basically graphiql with some simple caching
    - Apollo Client (apollo stack)
        - creators of MeteorJS; good balance between features/complexity
        - has its own backend GraphQL server and frontend client
        - breaks Types and Resolvers into their own files, enforces own syntax
    - Relay 
        - solid performance for mobile
        - insanely complex, especially with mutations
        - used by Facebook
- Apollo Stack
    - 'apollo-client'; 'react-apollo';
    - draws heavily from redux 
    - Apollo Store, client side repository populated by GraphQL server
        - `new ApolloClient({})`
            - assumes GraphQL server is available on `/graphql` route
                - `app.use('/graphql', expressGraphQL({ schema }));`
    - Apollo Provider, react component, injects data from store into React app
        - `<ApolloProvider client={client}>`, pass reference to store
- GraphQL + React strategy
    - identify specific data required
    - write query in graphiql and in component file
    - bond query + component with 'react-apollo'
    - access data
    

# Frontend

- `import gql from 'graphql-tag';` 
    - helper library handles queries in react component files
    - gql`{ query { etc } }` => defines a query
- `import { graphql } from 'react-apollo';`
    - bonds like redux connect, or reduxForm HOC
        - `export default graphql(query)(SongList);`
    - when component is mounted, query is executed
    - graphql nests results in `data` property on `props`, under key from query
        - changes a bit when wrapping a mutation => `props.mutate`
- **query variables** for mutations
    - provides data from react component class to gql query
    - named mutation syntax
        - add name, parameter and parameter type to mutation declaration
        - can be used as a function in app that takes customizable arguments
            - `mutation AddSongFunc($title: String) { addSong(title: $title) { id, title }}`
            - `mutation NameOfMutation($variableName: Type) { query(argumentName, $variableName) { properties returned } }`
            - basically same syntax for named queries
            - add `!` to enforce validation
                - `query SomeQuery($id: ID!)`
    - function is passed to component through `props.mutate`, which accepts a *query configuration object*
        - arguments (query variables) are passed through *variables* property
            - `this.props.mutate({ variables: { title: this.state.title } })`
    - `props.mutate` returns a promise
        - can help ensure user navigation only after a mutation has been successfully submitted to the server
        - `.then(() => navigate n stuff).catch(() => handle validations n stuff)`
            - also a good spot for loader logic
    - passing *query variables* to a *mutation* is very different from passing variables to a *query* 
        - `this.props.mutate({ variables })` vs `export default graphql(query)(Component)`, respectively, for example
        - remember, queries are executed automatically by GQL, but mutations are called invoked by dev
        - Apollo provides an (extremely ugly) interface to inject vars into query (specifically, into graphql wrapper)
            - graphql wrapper function accepts second argument: object with `options` property, return a callback
            - NB: graphql has access to component `props`, which we pass as an argument to the options callback
            - return `variables` object, similarly to calling mutation
            - nest query variables in variables object: `variables: { id: props.params.id }`
- beware Apollo query caching, list fetching
    - queries are executed when component mounts, but not if query was cached from previous mount
    - example: ItemList component loads, executes query
        - user navigates to CreateItem component; adds item to list; 
            - user navigates back to ItemList component; item is not present in list
    - need to manually refetch queries with Apollo
        - add `refetchQueries` property to the mutate *query configuration object*
            - accepts a list of objects (queries) that will be automatically rerun after mutation is successfully executed
            - object takes 2 properties: *query* and *variables*
        - or `this.props.data.refetch()`
            - automatically refetches any queries associated with component
        - use between the two methods depends on how the query is associated with the component
- [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/)
    - caching with DataIdFromObject
    - when Apollo fetches data, it has no idea which piece of data is which
    - `ApolloClient({ dataIdFromObject: o => o.id })` where o stands for object
        - processes every piece of data that is fetched by Apollo client
        - assigns id to that data in the store
        - requires that every query returns some kind of unique id
    - internally, causes Apollo client to associate data in store with id
        - Provider communicates updates to store to React app, triggers rerender of any component using that id
    - cuts down the number of api calls, rerender won't trigger refetch
- integrating 2 separate pieces of GraphQL code into a single component is tricky
    - 'graphql' function is not setup to take multiple queries or mutations
        - cannot double up on queries, although there's a workaround for mutations
            - e.g. cannot do `export default graphql(query, mutation)(Component)`;
        - instead, invoke `graphql()` helper *twice...*
            - `graphql(mutation)(graphql(fetchSongsQuery)(SongList));`
            - Apollo may have been updated at this point to handle this
- optimistic updates/responses
    - guess at a response, use as placeholder for value until response comes back from server
    - configured in mutation call
        - must model exactly the HTTP/XHR request
- misc
    - mapping over an array, have to sometimes overfetch and grab id's for react keys
    - Provider should wrap Router, keep Router as parent to Routes
    - materialize's css assumes you're using a root component with className="container"
    - forcible navigation inside a component with react-router: 
        - withRouter HOC
        - grab router off 'context' property
        - grab router off 'props' object